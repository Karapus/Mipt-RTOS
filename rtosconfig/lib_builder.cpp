#include "lib_builder.h"
#include "parser.h"
#include <fstream>
#include <cassert>
#include <boost/algorithm/string/predicate.hpp> // case insensitive strings comparison

void LibBuilder::build()
{
	m_config = m_parser->parse();

	try {

	std::filesystem::remove_all(m_build_path); // clear if exists
	std::filesystem::create_directory(m_build_path);

	std::ofstream rtos_h(m_build_path / "rtos.h");
	std::ofstream rtos_cpp(m_build_path / "rtos.cpp");

	make_rtos_h(rtos_h);
	make_rtos_cpp(rtos_cpp);
	make_impl_files();

	} catch (std::exception& e) {
		std::filesystem::remove_all(m_build_path); // clear on failure
		throw;
	}
}


/***********************************************************/


void LibBuilder::make_rtos_h(std::ostream& os)
{
	make_description_section(os, "rtos.h: Mipt-RTOS configuration file");
	os <<
R"(
#include "impl/include/kernel_module.h"

#define decltask(taskname) void detail::__##taskname##_routine(void)

namespace detail {

)";
	for (auto& task : m_config.tasks)
		os << "void __" << task.name << "_routine(void);" << std::endl;
	os <<
R"(
} // detail namespace end

using rt::kernel;

)";
	size_t i = 0;
	for (auto& task : m_config.tasks) {
		os << "inline rt::Task& " << task.name << " = "
			<< "kernel.task(" << i++ << ");" << std::endl;
	}
}


/***********************************************************/


void LibBuilder::make_rtos_cpp(std::ostream& os)
{
	make_description_section(os, "rtos.cpp: Mipt-RTOS configuration file");
	os <<
R"(
#include "rtos.h"

namespace rt {

Kernel Kernel::m_only_one;

const task_id_t Kernel::m_ntasks = )" << m_config.tasks.size() <<  R"(;

Task Kernel::m_tasks[Kernel::m_ntasks] = {
)";
	size_t i = 0;
	for (auto& task : m_config.tasks) {
		os << "\tTask(detail::__" << task.name << "_routine, "
			<< task.stack_size << ")" << ((++i != m_config.tasks.size()) ? "," : "") << std::endl;
	}
	os <<
R"(};

task_id_t Kernel::m_current_task = 0;

} // rt namespace end

#include "impl/src/kernel_module.cpp"

)";

}


/***********************************************************/


void LibBuilder::make_description_section(std::ostream& os, const std::string& header)
{
	os <<
R"(/* )" << header << R"(
 * 
 * Copyright (C) 2021 Mipt-RTOS
 *
 * This file is automatically generated by rtosconfig
 * See Mipt-RTOS documentation on https://github.com/graudtV/Mipt-RTOS
 *
 * User project configuration details
 * Platform: )" << m_config.platform << R"(
 * Tasks:
)";
	for (auto& task : m_config.tasks)
		os << " *\t" << task.name << "\t[stack_size = " << task.stack_size << "]" << std::endl;
	os << " */" << std::endl;
}


/***********************************************************/


void LibBuilder::make_impl_files()
{
	auto impl_path = m_build_path / "impl";
	auto headers_path = impl_path / "include";
	auto sources_path = impl_path / "src";

	std::filesystem::create_directory(impl_path);
	std::filesystem::create_directory(headers_path);
	std::filesystem::create_directory(sources_path);

	std::filesystem::copy_file(m_header_templates / "kernel_module.h", headers_path / "kernel_module.h");
	std::filesystem::copy_file(m_source_templates / "kernel_module.cpp", sources_path / "kernel_module.cpp");
	
	if (boost::iequals(m_config.platform, "Linux_x86")) {
		std::filesystem::copy_file(m_header_templates / "platform_linux_x86.h", headers_path / "platform.h");
		std::filesystem::copy_file(m_header_templates / "asm_macro_linux_x86.h", headers_path / "asm_macro.h");
	} else {
		throw std::runtime_error("unkwown platform: " + m_config.platform);
	}
}