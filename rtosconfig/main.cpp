#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <fstream>
#include <iostream>
#include <string>
#include <string_view>
#include <cctype>
#include <set>
#include <cassert>

using namespace std::string_literals;
namespace pt = boost::property_tree;

struct TaskConfig {
	std::string name;
	size_t stack_size;

	void load(pt::ptree& tree);
};

struct PlatformConfig {
	std::string platform;
	std::vector<TaskConfig> tasks;

	void load(pt::ptree& tree);
	void check_correctness();
	void make_header_file(std::ostream& os);
	void make_source_file(std::ostream& os);
private:
	void make_description_section(std::ostream& os);
};

void TaskConfig::load(pt::ptree& tree)
try {
	name = tree.get<std::string>("name");
	stack_size = tree.get<size_t>("stack_size");
} catch (pt::ptree_bad_path& e) {
	throw std::runtime_error("Task must contain property '"s
		+ e.path<pt::ptree::path_type>().dump() + "'");
}

void PlatformConfig::load(pt::ptree& tree)
try {
	platform = tree.get<std::string>("Platform");

	for (auto& task : tree.get_child("Tasks")) {
		TaskConfig task_config;
		task_config.load(task.second);
		tasks.push_back(task_config);
	}
	check_correctness();
} catch (pt::ptree_bad_path& e) {
	throw std::runtime_error("Config file must contain property '"s
		+ e.path<pt::ptree::path_type>().dump() + "'");
}

void PlatformConfig::check_correctness()
{
	if (tasks.size() == 0)
		throw std::runtime_error("No tasks specified");
	for (auto& task : tasks) {
		if (task.name.empty())
			throw std::runtime_error("Task with empty name is found");
		if (!(isalpha(task.name[0]) || task.name[0] == '_'))
			throw std::runtime_error("Incorrect task name '"s
				+ task.name + "'. Task names must be C-style identifiers");
	}
	{ /* Check if all tasks have different names */
		std::set<std::string_view> task_names;
		for (auto& task : tasks)
			task_names.insert(task.name);
		if (task_names.size() != tasks.size())
			throw std::runtime_error("Some tasks have equal names");
	}
}


/***********************************************************/


void PlatformConfig::make_header_file(std::ostream& os)
{
	make_description_section(os);
	os <<
R"(
#include <Mipt-RTOS/kernel_module.h>

#define decltask(taskname) void detail::__##taskname##_routine(void)

namespace detail {

)";
	for (auto& task : tasks)
		os << "void __" << task.name << "_routine(void);" << std::endl;
	os <<
R"(
} // detail namespace end

using rt::kernel;

)";
	size_t i = 0;
	for (auto& task : tasks) {
		os << "inline rt::Task& " << task.name << " = "
			<< "kernel.task(" << i++ << ");" << std::endl;
	}
}


/***********************************************************/


void PlatformConfig::make_source_file(std::ostream& os)
{
	make_description_section(os);
	os <<
R"(
#include "rtos.h"

namespace rt {

Kernel Kernel::m_only_one;

const task_id_t Kernel::m_ntasks = )" << tasks.size() <<  R"(;

Task Kernel::m_tasks[Kernel::m_ntasks] = {
)";
	size_t i = 0;
	for (auto& task : tasks) {
		os << "\tTask(detail::__" << task.name << "_routine, "
			<< task.stack_size << ")" << ((++i != tasks.size()) ? "," : "") << std::endl;
	}
	os <<
R"(};

task_id_t Kernel::m_current_task = 0;

} // rt namespace end
)";

}


/***********************************************************/


void PlatformConfig::make_description_section(std::ostream& os)
{
	os <<
R"(/* Mipt-RTOS configuration file
 * 
 * Copyright (C) 2021 Mipt-RTOS
 *
 * This file is automatically generated by rtosconfig
 * See Mipt-RTOS documentation on https://github.com/graudtV/Mipt-RTOS
 *
 * User project configuration details
 * Platform: )" << platform << R"(
 * Tasks:
)";
	for (auto& task : tasks)
		os << " *\t" << task.name << "\t[stack_size = " << task.stack_size << "]" << std::endl;
	os << " */" << std::endl;
}


/***********************************************************/


int main(int argc, char *argv[])
try {
	const char *config_file_name = nullptr;
	const char *header_file_name = "rtos.h";
	const char *source_file_name = "rtos.cpp";

	if (argc != 2) {
		std::cerr << "Usage: rtosconfig config_file_name.json" << std::endl;
		return EXIT_FAILURE;	
	}
	config_file_name = argv[1];

	std::ifstream fin(config_file_name);
	if (!fin)
		throw std::runtime_error("cannot open file '"s + config_file_name + "'");

	pt::ptree tree;
	pt::read_json(fin, tree);

	PlatformConfig config;

	config.load(tree);

	std::ofstream fout_header(header_file_name);
	config.make_header_file(fout_header);

	std::ofstream fout_source(source_file_name);
	config.make_source_file(fout_source);

	std::cerr << "Configuration written into files "
		<< header_file_name << " and "
		<< source_file_name << std::endl; 
	return EXIT_SUCCESS;
} catch (std::exception& e) {
	std::cerr << "Configuration failure: " << e.what() << std::endl;
	return EXIT_FAILURE;
}
